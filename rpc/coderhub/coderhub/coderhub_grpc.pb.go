// goctl rpc protoc coderhub.proto --go_out=../ --go-grpc_out=../ --zrpc_out=../ -m

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v4.25.3
// source: coderhub.proto

package coderhub

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	UserService_Authorize_FullMethodName             = "/coderhub.UserService/Authorize"
	UserService_CheckUserExists_FullMethodName       = "/coderhub.UserService/CheckUserExists"
	UserService_CreateUser_FullMethodName            = "/coderhub.UserService/CreateUser"
	UserService_GetUserInfo_FullMethodName           = "/coderhub.UserService/GetUserInfo"
	UserService_GetUserInfoByUsername_FullMethodName = "/coderhub.UserService/GetUserInfoByUsername"
	UserService_BatchGetUserByID_FullMethodName      = "/coderhub.UserService/BatchGetUserByID"
	UserService_UpdateUserInfo_FullMethodName        = "/coderhub.UserService/UpdateUserInfo"
	UserService_UploadAvatar_FullMethodName          = "/coderhub.UserService/UploadAvatar"
	UserService_ChangePassword_FullMethodName        = "/coderhub.UserService/ChangePassword"
	UserService_ResetPassword_FullMethodName         = "/coderhub.UserService/ResetPassword"
	UserService_ResetPasswordByLink_FullMethodName   = "/coderhub.UserService/ResetPasswordByLink"
	UserService_DeleteUser_FullMethodName            = "/coderhub.UserService/DeleteUser"
)

// UserServiceClient is the client API for UserService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserServiceClient interface {
	// 授权
	Authorize(ctx context.Context, in *AuthorizeRequest, opts ...grpc.CallOption) (*AuthorizeResponse, error)
	// 检查用户是否存在
	CheckUserExists(ctx context.Context, in *CheckUserExistsRequest, opts ...grpc.CallOption) (*CheckUserExistsResponse, error)
	// 创建用户
	CreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*CreateUserResponse, error)
	// 获取用户信息
	GetUserInfo(ctx context.Context, in *GetUserInfoRequest, opts ...grpc.CallOption) (*UserInfo, error)
	GetUserInfoByUsername(ctx context.Context, in *GetUserInfoByUsernameRequest, opts ...grpc.CallOption) (*UserInfo, error)
	// 批量获取用户信息
	BatchGetUserByID(ctx context.Context, in *BatchGetUserByIDRequest, opts ...grpc.CallOption) (*BatchGetUserByIDResponse, error)
	// 更新用户信息
	UpdateUserInfo(ctx context.Context, in *UpdateUserInfoRequest, opts ...grpc.CallOption) (*UpdateUserInfoResponse, error)
	// 上传用户头像
	UploadAvatar(ctx context.Context, in *UploadAvatarRequest, opts ...grpc.CallOption) (*UploadAvatarResponse, error)
	// 修改密码
	ChangePassword(ctx context.Context, in *ChangePasswordRequest, opts ...grpc.CallOption) (*ChangePasswordResponse, error)
	// 重置密码, 通过邮箱发送重置密码链接
	ResetPassword(ctx context.Context, in *ResetPasswordRequest, opts ...grpc.CallOption) (*ResetPasswordResponse, error)
	// 通过链接重置密码
	ResetPasswordByLink(ctx context.Context, in *ResetPasswordByLinkRequest, opts ...grpc.CallOption) (*ResetPasswordByLinkResponse, error)
	// 删除用户
	DeleteUser(ctx context.Context, in *DeleteUserRequest, opts ...grpc.CallOption) (*DeleteUserResponse, error)
}

type userServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserServiceClient(cc grpc.ClientConnInterface) UserServiceClient {
	return &userServiceClient{cc}
}

func (c *userServiceClient) Authorize(ctx context.Context, in *AuthorizeRequest, opts ...grpc.CallOption) (*AuthorizeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AuthorizeResponse)
	err := c.cc.Invoke(ctx, UserService_Authorize_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) CheckUserExists(ctx context.Context, in *CheckUserExistsRequest, opts ...grpc.CallOption) (*CheckUserExistsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CheckUserExistsResponse)
	err := c.cc.Invoke(ctx, UserService_CheckUserExists_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) CreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*CreateUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateUserResponse)
	err := c.cc.Invoke(ctx, UserService_CreateUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) GetUserInfo(ctx context.Context, in *GetUserInfoRequest, opts ...grpc.CallOption) (*UserInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserInfo)
	err := c.cc.Invoke(ctx, UserService_GetUserInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) GetUserInfoByUsername(ctx context.Context, in *GetUserInfoByUsernameRequest, opts ...grpc.CallOption) (*UserInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserInfo)
	err := c.cc.Invoke(ctx, UserService_GetUserInfoByUsername_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) BatchGetUserByID(ctx context.Context, in *BatchGetUserByIDRequest, opts ...grpc.CallOption) (*BatchGetUserByIDResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BatchGetUserByIDResponse)
	err := c.cc.Invoke(ctx, UserService_BatchGetUserByID_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) UpdateUserInfo(ctx context.Context, in *UpdateUserInfoRequest, opts ...grpc.CallOption) (*UpdateUserInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateUserInfoResponse)
	err := c.cc.Invoke(ctx, UserService_UpdateUserInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) UploadAvatar(ctx context.Context, in *UploadAvatarRequest, opts ...grpc.CallOption) (*UploadAvatarResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UploadAvatarResponse)
	err := c.cc.Invoke(ctx, UserService_UploadAvatar_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) ChangePassword(ctx context.Context, in *ChangePasswordRequest, opts ...grpc.CallOption) (*ChangePasswordResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ChangePasswordResponse)
	err := c.cc.Invoke(ctx, UserService_ChangePassword_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) ResetPassword(ctx context.Context, in *ResetPasswordRequest, opts ...grpc.CallOption) (*ResetPasswordResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResetPasswordResponse)
	err := c.cc.Invoke(ctx, UserService_ResetPassword_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) ResetPasswordByLink(ctx context.Context, in *ResetPasswordByLinkRequest, opts ...grpc.CallOption) (*ResetPasswordByLinkResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResetPasswordByLinkResponse)
	err := c.cc.Invoke(ctx, UserService_ResetPasswordByLink_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) DeleteUser(ctx context.Context, in *DeleteUserRequest, opts ...grpc.CallOption) (*DeleteUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteUserResponse)
	err := c.cc.Invoke(ctx, UserService_DeleteUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserServiceServer is the server API for UserService service.
// All implementations must embed UnimplementedUserServiceServer
// for forward compatibility.
type UserServiceServer interface {
	// 授权
	Authorize(context.Context, *AuthorizeRequest) (*AuthorizeResponse, error)
	// 检查用户是否存在
	CheckUserExists(context.Context, *CheckUserExistsRequest) (*CheckUserExistsResponse, error)
	// 创建用户
	CreateUser(context.Context, *CreateUserRequest) (*CreateUserResponse, error)
	// 获取用户信息
	GetUserInfo(context.Context, *GetUserInfoRequest) (*UserInfo, error)
	GetUserInfoByUsername(context.Context, *GetUserInfoByUsernameRequest) (*UserInfo, error)
	// 批量获取用户信息
	BatchGetUserByID(context.Context, *BatchGetUserByIDRequest) (*BatchGetUserByIDResponse, error)
	// 更新用户信息
	UpdateUserInfo(context.Context, *UpdateUserInfoRequest) (*UpdateUserInfoResponse, error)
	// 上传用户头像
	UploadAvatar(context.Context, *UploadAvatarRequest) (*UploadAvatarResponse, error)
	// 修改密码
	ChangePassword(context.Context, *ChangePasswordRequest) (*ChangePasswordResponse, error)
	// 重置密码, 通过邮箱发送重置密码链接
	ResetPassword(context.Context, *ResetPasswordRequest) (*ResetPasswordResponse, error)
	// 通过链接重置密码
	ResetPasswordByLink(context.Context, *ResetPasswordByLinkRequest) (*ResetPasswordByLinkResponse, error)
	// 删除用户
	DeleteUser(context.Context, *DeleteUserRequest) (*DeleteUserResponse, error)
	mustEmbedUnimplementedUserServiceServer()
}

// UnimplementedUserServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserServiceServer struct{}

func (UnimplementedUserServiceServer) Authorize(context.Context, *AuthorizeRequest) (*AuthorizeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Authorize not implemented")
}
func (UnimplementedUserServiceServer) CheckUserExists(context.Context, *CheckUserExistsRequest) (*CheckUserExistsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckUserExists not implemented")
}
func (UnimplementedUserServiceServer) CreateUser(context.Context, *CreateUserRequest) (*CreateUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateUser not implemented")
}
func (UnimplementedUserServiceServer) GetUserInfo(context.Context, *GetUserInfoRequest) (*UserInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserInfo not implemented")
}
func (UnimplementedUserServiceServer) GetUserInfoByUsername(context.Context, *GetUserInfoByUsernameRequest) (*UserInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserInfoByUsername not implemented")
}
func (UnimplementedUserServiceServer) BatchGetUserByID(context.Context, *BatchGetUserByIDRequest) (*BatchGetUserByIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchGetUserByID not implemented")
}
func (UnimplementedUserServiceServer) UpdateUserInfo(context.Context, *UpdateUserInfoRequest) (*UpdateUserInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUserInfo not implemented")
}
func (UnimplementedUserServiceServer) UploadAvatar(context.Context, *UploadAvatarRequest) (*UploadAvatarResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UploadAvatar not implemented")
}
func (UnimplementedUserServiceServer) ChangePassword(context.Context, *ChangePasswordRequest) (*ChangePasswordResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChangePassword not implemented")
}
func (UnimplementedUserServiceServer) ResetPassword(context.Context, *ResetPasswordRequest) (*ResetPasswordResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetPassword not implemented")
}
func (UnimplementedUserServiceServer) ResetPasswordByLink(context.Context, *ResetPasswordByLinkRequest) (*ResetPasswordByLinkResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetPasswordByLink not implemented")
}
func (UnimplementedUserServiceServer) DeleteUser(context.Context, *DeleteUserRequest) (*DeleteUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUser not implemented")
}
func (UnimplementedUserServiceServer) mustEmbedUnimplementedUserServiceServer() {}
func (UnimplementedUserServiceServer) testEmbeddedByValue()                     {}

// UnsafeUserServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserServiceServer will
// result in compilation errors.
type UnsafeUserServiceServer interface {
	mustEmbedUnimplementedUserServiceServer()
}

func RegisterUserServiceServer(s grpc.ServiceRegistrar, srv UserServiceServer) {
	// If the following call pancis, it indicates UnimplementedUserServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserService_ServiceDesc, srv)
}

func _UserService_Authorize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthorizeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).Authorize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_Authorize_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).Authorize(ctx, req.(*AuthorizeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_CheckUserExists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckUserExistsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).CheckUserExists(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_CheckUserExists_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).CheckUserExists(ctx, req.(*CheckUserExistsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_CreateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).CreateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_CreateUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).CreateUser(ctx, req.(*CreateUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_GetUserInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetUserInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_GetUserInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetUserInfo(ctx, req.(*GetUserInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_GetUserInfoByUsername_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserInfoByUsernameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetUserInfoByUsername(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_GetUserInfoByUsername_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetUserInfoByUsername(ctx, req.(*GetUserInfoByUsernameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_BatchGetUserByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchGetUserByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).BatchGetUserByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_BatchGetUserByID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).BatchGetUserByID(ctx, req.(*BatchGetUserByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_UpdateUserInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).UpdateUserInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_UpdateUserInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).UpdateUserInfo(ctx, req.(*UpdateUserInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_UploadAvatar_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UploadAvatarRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).UploadAvatar(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_UploadAvatar_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).UploadAvatar(ctx, req.(*UploadAvatarRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_ChangePassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChangePasswordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).ChangePassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_ChangePassword_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).ChangePassword(ctx, req.(*ChangePasswordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_ResetPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetPasswordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).ResetPassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_ResetPassword_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).ResetPassword(ctx, req.(*ResetPasswordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_ResetPasswordByLink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetPasswordByLinkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).ResetPasswordByLink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_ResetPasswordByLink_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).ResetPasswordByLink(ctx, req.(*ResetPasswordByLinkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_DeleteUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).DeleteUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_DeleteUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).DeleteUser(ctx, req.(*DeleteUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// UserService_ServiceDesc is the grpc.ServiceDesc for UserService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "coderhub.UserService",
	HandlerType: (*UserServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Authorize",
			Handler:    _UserService_Authorize_Handler,
		},
		{
			MethodName: "CheckUserExists",
			Handler:    _UserService_CheckUserExists_Handler,
		},
		{
			MethodName: "CreateUser",
			Handler:    _UserService_CreateUser_Handler,
		},
		{
			MethodName: "GetUserInfo",
			Handler:    _UserService_GetUserInfo_Handler,
		},
		{
			MethodName: "GetUserInfoByUsername",
			Handler:    _UserService_GetUserInfoByUsername_Handler,
		},
		{
			MethodName: "BatchGetUserByID",
			Handler:    _UserService_BatchGetUserByID_Handler,
		},
		{
			MethodName: "UpdateUserInfo",
			Handler:    _UserService_UpdateUserInfo_Handler,
		},
		{
			MethodName: "UploadAvatar",
			Handler:    _UserService_UploadAvatar_Handler,
		},
		{
			MethodName: "ChangePassword",
			Handler:    _UserService_ChangePassword_Handler,
		},
		{
			MethodName: "ResetPassword",
			Handler:    _UserService_ResetPassword_Handler,
		},
		{
			MethodName: "ResetPasswordByLink",
			Handler:    _UserService_ResetPasswordByLink_Handler,
		},
		{
			MethodName: "DeleteUser",
			Handler:    _UserService_DeleteUser_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "coderhub.proto",
}

const (
	UserFollowService_CreateUserFollow_FullMethodName = "/coderhub.UserFollowService/CreateUserFollow"
	UserFollowService_DeleteUserFollow_FullMethodName = "/coderhub.UserFollowService/DeleteUserFollow"
	UserFollowService_GetUserFollows_FullMethodName   = "/coderhub.UserFollowService/GetUserFollows"
	UserFollowService_GetUserFans_FullMethodName      = "/coderhub.UserFollowService/GetUserFans"
	UserFollowService_IsUserFollowed_FullMethodName   = "/coderhub.UserFollowService/IsUserFollowed"
	UserFollowService_GetMutualFollows_FullMethodName = "/coderhub.UserFollowService/GetMutualFollows"
)

// UserFollowServiceClient is the client API for UserFollowService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserFollowServiceClient interface {
	// 创建用户关注关系
	CreateUserFollow(ctx context.Context, in *CreateUserFollowReq, opts ...grpc.CallOption) (*CreateUserFollowResp, error)
	// 删除用户关注关系
	DeleteUserFollow(ctx context.Context, in *DeleteUserFollowReq, opts ...grpc.CallOption) (*DeleteUserFollowResp, error)
	// 获取用户关注列表
	GetUserFollows(ctx context.Context, in *GetUserFollowsReq, opts ...grpc.CallOption) (*GetUserFollowsResp, error)
	// 获取用户粉丝列表
	GetUserFans(ctx context.Context, in *GetUserFansReq, opts ...grpc.CallOption) (*GetUserFansResp, error)
	// 检查是否关注
	IsUserFollowed(ctx context.Context, in *IsUserFollowedReq, opts ...grpc.CallOption) (*IsUserFollowedResp, error)
	// 获取互相关注列表
	GetMutualFollows(ctx context.Context, in *GetMutualFollowsReq, opts ...grpc.CallOption) (*GetMutualFollowsResp, error)
}

type userFollowServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserFollowServiceClient(cc grpc.ClientConnInterface) UserFollowServiceClient {
	return &userFollowServiceClient{cc}
}

func (c *userFollowServiceClient) CreateUserFollow(ctx context.Context, in *CreateUserFollowReq, opts ...grpc.CallOption) (*CreateUserFollowResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateUserFollowResp)
	err := c.cc.Invoke(ctx, UserFollowService_CreateUserFollow_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userFollowServiceClient) DeleteUserFollow(ctx context.Context, in *DeleteUserFollowReq, opts ...grpc.CallOption) (*DeleteUserFollowResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteUserFollowResp)
	err := c.cc.Invoke(ctx, UserFollowService_DeleteUserFollow_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userFollowServiceClient) GetUserFollows(ctx context.Context, in *GetUserFollowsReq, opts ...grpc.CallOption) (*GetUserFollowsResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUserFollowsResp)
	err := c.cc.Invoke(ctx, UserFollowService_GetUserFollows_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userFollowServiceClient) GetUserFans(ctx context.Context, in *GetUserFansReq, opts ...grpc.CallOption) (*GetUserFansResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUserFansResp)
	err := c.cc.Invoke(ctx, UserFollowService_GetUserFans_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userFollowServiceClient) IsUserFollowed(ctx context.Context, in *IsUserFollowedReq, opts ...grpc.CallOption) (*IsUserFollowedResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IsUserFollowedResp)
	err := c.cc.Invoke(ctx, UserFollowService_IsUserFollowed_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userFollowServiceClient) GetMutualFollows(ctx context.Context, in *GetMutualFollowsReq, opts ...grpc.CallOption) (*GetMutualFollowsResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetMutualFollowsResp)
	err := c.cc.Invoke(ctx, UserFollowService_GetMutualFollows_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserFollowServiceServer is the server API for UserFollowService service.
// All implementations must embed UnimplementedUserFollowServiceServer
// for forward compatibility.
type UserFollowServiceServer interface {
	// 创建用户关注关系
	CreateUserFollow(context.Context, *CreateUserFollowReq) (*CreateUserFollowResp, error)
	// 删除用户关注关系
	DeleteUserFollow(context.Context, *DeleteUserFollowReq) (*DeleteUserFollowResp, error)
	// 获取用户关注列表
	GetUserFollows(context.Context, *GetUserFollowsReq) (*GetUserFollowsResp, error)
	// 获取用户粉丝列表
	GetUserFans(context.Context, *GetUserFansReq) (*GetUserFansResp, error)
	// 检查是否关注
	IsUserFollowed(context.Context, *IsUserFollowedReq) (*IsUserFollowedResp, error)
	// 获取互相关注列表
	GetMutualFollows(context.Context, *GetMutualFollowsReq) (*GetMutualFollowsResp, error)
	mustEmbedUnimplementedUserFollowServiceServer()
}

// UnimplementedUserFollowServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserFollowServiceServer struct{}

func (UnimplementedUserFollowServiceServer) CreateUserFollow(context.Context, *CreateUserFollowReq) (*CreateUserFollowResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateUserFollow not implemented")
}
func (UnimplementedUserFollowServiceServer) DeleteUserFollow(context.Context, *DeleteUserFollowReq) (*DeleteUserFollowResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUserFollow not implemented")
}
func (UnimplementedUserFollowServiceServer) GetUserFollows(context.Context, *GetUserFollowsReq) (*GetUserFollowsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserFollows not implemented")
}
func (UnimplementedUserFollowServiceServer) GetUserFans(context.Context, *GetUserFansReq) (*GetUserFansResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserFans not implemented")
}
func (UnimplementedUserFollowServiceServer) IsUserFollowed(context.Context, *IsUserFollowedReq) (*IsUserFollowedResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsUserFollowed not implemented")
}
func (UnimplementedUserFollowServiceServer) GetMutualFollows(context.Context, *GetMutualFollowsReq) (*GetMutualFollowsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMutualFollows not implemented")
}
func (UnimplementedUserFollowServiceServer) mustEmbedUnimplementedUserFollowServiceServer() {}
func (UnimplementedUserFollowServiceServer) testEmbeddedByValue()                           {}

// UnsafeUserFollowServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserFollowServiceServer will
// result in compilation errors.
type UnsafeUserFollowServiceServer interface {
	mustEmbedUnimplementedUserFollowServiceServer()
}

func RegisterUserFollowServiceServer(s grpc.ServiceRegistrar, srv UserFollowServiceServer) {
	// If the following call pancis, it indicates UnimplementedUserFollowServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserFollowService_ServiceDesc, srv)
}

func _UserFollowService_CreateUserFollow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateUserFollowReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserFollowServiceServer).CreateUserFollow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserFollowService_CreateUserFollow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserFollowServiceServer).CreateUserFollow(ctx, req.(*CreateUserFollowReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserFollowService_DeleteUserFollow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteUserFollowReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserFollowServiceServer).DeleteUserFollow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserFollowService_DeleteUserFollow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserFollowServiceServer).DeleteUserFollow(ctx, req.(*DeleteUserFollowReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserFollowService_GetUserFollows_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserFollowsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserFollowServiceServer).GetUserFollows(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserFollowService_GetUserFollows_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserFollowServiceServer).GetUserFollows(ctx, req.(*GetUserFollowsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserFollowService_GetUserFans_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserFansReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserFollowServiceServer).GetUserFans(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserFollowService_GetUserFans_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserFollowServiceServer).GetUserFans(ctx, req.(*GetUserFansReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserFollowService_IsUserFollowed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsUserFollowedReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserFollowServiceServer).IsUserFollowed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserFollowService_IsUserFollowed_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserFollowServiceServer).IsUserFollowed(ctx, req.(*IsUserFollowedReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserFollowService_GetMutualFollows_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMutualFollowsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserFollowServiceServer).GetMutualFollows(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserFollowService_GetMutualFollows_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserFollowServiceServer).GetMutualFollows(ctx, req.(*GetMutualFollowsReq))
	}
	return interceptor(ctx, in, info, handler)
}

// UserFollowService_ServiceDesc is the grpc.ServiceDesc for UserFollowService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserFollowService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "coderhub.UserFollowService",
	HandlerType: (*UserFollowServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateUserFollow",
			Handler:    _UserFollowService_CreateUserFollow_Handler,
		},
		{
			MethodName: "DeleteUserFollow",
			Handler:    _UserFollowService_DeleteUserFollow_Handler,
		},
		{
			MethodName: "GetUserFollows",
			Handler:    _UserFollowService_GetUserFollows_Handler,
		},
		{
			MethodName: "GetUserFans",
			Handler:    _UserFollowService_GetUserFans_Handler,
		},
		{
			MethodName: "IsUserFollowed",
			Handler:    _UserFollowService_IsUserFollowed_Handler,
		},
		{
			MethodName: "GetMutualFollows",
			Handler:    _UserFollowService_GetMutualFollows_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "coderhub.proto",
}

const (
	AcademicNavigatorService_AddAcademicNavigator_FullMethodName        = "/coderhub.AcademicNavigatorService/AddAcademicNavigator"
	AcademicNavigatorService_GetAcademicNavigator_FullMethodName        = "/coderhub.AcademicNavigatorService/GetAcademicNavigator"
	AcademicNavigatorService_DeleteAcademicNavigator_FullMethodName     = "/coderhub.AcademicNavigatorService/DeleteAcademicNavigator"
	AcademicNavigatorService_LikeAcademicNavigator_FullMethodName       = "/coderhub.AcademicNavigatorService/LikeAcademicNavigator"
	AcademicNavigatorService_CancelLikeAcademicNavigator_FullMethodName = "/coderhub.AcademicNavigatorService/CancelLikeAcademicNavigator"
)

// AcademicNavigatorServiceClient is the client API for AcademicNavigatorService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AcademicNavigatorServiceClient interface {
	// 新增学术导航
	AddAcademicNavigator(ctx context.Context, in *AddAcademicNavigatorRequest, opts ...grpc.CallOption) (*Response, error)
	// 获取学术导航
	GetAcademicNavigator(ctx context.Context, in *GetAcademicNavigatorRequest, opts ...grpc.CallOption) (*GetAcademicNavigatorResponse, error)
	// 删除学术导航
	DeleteAcademicNavigator(ctx context.Context, in *DeleteAcademicNavigatorRequest, opts ...grpc.CallOption) (*Response, error)
	// 点赞学术导航
	LikeAcademicNavigator(ctx context.Context, in *LikeAcademicNavigatorRequest, opts ...grpc.CallOption) (*Response, error)
	// 取消点赞学术导航
	CancelLikeAcademicNavigator(ctx context.Context, in *CancelLikeAcademicNavigatorRequest, opts ...grpc.CallOption) (*Response, error)
}

type academicNavigatorServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAcademicNavigatorServiceClient(cc grpc.ClientConnInterface) AcademicNavigatorServiceClient {
	return &academicNavigatorServiceClient{cc}
}

func (c *academicNavigatorServiceClient) AddAcademicNavigator(ctx context.Context, in *AddAcademicNavigatorRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, AcademicNavigatorService_AddAcademicNavigator_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *academicNavigatorServiceClient) GetAcademicNavigator(ctx context.Context, in *GetAcademicNavigatorRequest, opts ...grpc.CallOption) (*GetAcademicNavigatorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAcademicNavigatorResponse)
	err := c.cc.Invoke(ctx, AcademicNavigatorService_GetAcademicNavigator_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *academicNavigatorServiceClient) DeleteAcademicNavigator(ctx context.Context, in *DeleteAcademicNavigatorRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, AcademicNavigatorService_DeleteAcademicNavigator_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *academicNavigatorServiceClient) LikeAcademicNavigator(ctx context.Context, in *LikeAcademicNavigatorRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, AcademicNavigatorService_LikeAcademicNavigator_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *academicNavigatorServiceClient) CancelLikeAcademicNavigator(ctx context.Context, in *CancelLikeAcademicNavigatorRequest, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, AcademicNavigatorService_CancelLikeAcademicNavigator_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AcademicNavigatorServiceServer is the server API for AcademicNavigatorService service.
// All implementations must embed UnimplementedAcademicNavigatorServiceServer
// for forward compatibility.
type AcademicNavigatorServiceServer interface {
	// 新增学术导航
	AddAcademicNavigator(context.Context, *AddAcademicNavigatorRequest) (*Response, error)
	// 获取学术导航
	GetAcademicNavigator(context.Context, *GetAcademicNavigatorRequest) (*GetAcademicNavigatorResponse, error)
	// 删除学术导航
	DeleteAcademicNavigator(context.Context, *DeleteAcademicNavigatorRequest) (*Response, error)
	// 点赞学术导航
	LikeAcademicNavigator(context.Context, *LikeAcademicNavigatorRequest) (*Response, error)
	// 取消点赞学术导航
	CancelLikeAcademicNavigator(context.Context, *CancelLikeAcademicNavigatorRequest) (*Response, error)
	mustEmbedUnimplementedAcademicNavigatorServiceServer()
}

// UnimplementedAcademicNavigatorServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAcademicNavigatorServiceServer struct{}

func (UnimplementedAcademicNavigatorServiceServer) AddAcademicNavigator(context.Context, *AddAcademicNavigatorRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddAcademicNavigator not implemented")
}
func (UnimplementedAcademicNavigatorServiceServer) GetAcademicNavigator(context.Context, *GetAcademicNavigatorRequest) (*GetAcademicNavigatorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAcademicNavigator not implemented")
}
func (UnimplementedAcademicNavigatorServiceServer) DeleteAcademicNavigator(context.Context, *DeleteAcademicNavigatorRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAcademicNavigator not implemented")
}
func (UnimplementedAcademicNavigatorServiceServer) LikeAcademicNavigator(context.Context, *LikeAcademicNavigatorRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LikeAcademicNavigator not implemented")
}
func (UnimplementedAcademicNavigatorServiceServer) CancelLikeAcademicNavigator(context.Context, *CancelLikeAcademicNavigatorRequest) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelLikeAcademicNavigator not implemented")
}
func (UnimplementedAcademicNavigatorServiceServer) mustEmbedUnimplementedAcademicNavigatorServiceServer() {
}
func (UnimplementedAcademicNavigatorServiceServer) testEmbeddedByValue() {}

// UnsafeAcademicNavigatorServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AcademicNavigatorServiceServer will
// result in compilation errors.
type UnsafeAcademicNavigatorServiceServer interface {
	mustEmbedUnimplementedAcademicNavigatorServiceServer()
}

func RegisterAcademicNavigatorServiceServer(s grpc.ServiceRegistrar, srv AcademicNavigatorServiceServer) {
	// If the following call pancis, it indicates UnimplementedAcademicNavigatorServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AcademicNavigatorService_ServiceDesc, srv)
}

func _AcademicNavigatorService_AddAcademicNavigator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddAcademicNavigatorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AcademicNavigatorServiceServer).AddAcademicNavigator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AcademicNavigatorService_AddAcademicNavigator_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AcademicNavigatorServiceServer).AddAcademicNavigator(ctx, req.(*AddAcademicNavigatorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AcademicNavigatorService_GetAcademicNavigator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAcademicNavigatorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AcademicNavigatorServiceServer).GetAcademicNavigator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AcademicNavigatorService_GetAcademicNavigator_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AcademicNavigatorServiceServer).GetAcademicNavigator(ctx, req.(*GetAcademicNavigatorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AcademicNavigatorService_DeleteAcademicNavigator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAcademicNavigatorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AcademicNavigatorServiceServer).DeleteAcademicNavigator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AcademicNavigatorService_DeleteAcademicNavigator_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AcademicNavigatorServiceServer).DeleteAcademicNavigator(ctx, req.(*DeleteAcademicNavigatorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AcademicNavigatorService_LikeAcademicNavigator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LikeAcademicNavigatorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AcademicNavigatorServiceServer).LikeAcademicNavigator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AcademicNavigatorService_LikeAcademicNavigator_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AcademicNavigatorServiceServer).LikeAcademicNavigator(ctx, req.(*LikeAcademicNavigatorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AcademicNavigatorService_CancelLikeAcademicNavigator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelLikeAcademicNavigatorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AcademicNavigatorServiceServer).CancelLikeAcademicNavigator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AcademicNavigatorService_CancelLikeAcademicNavigator_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AcademicNavigatorServiceServer).CancelLikeAcademicNavigator(ctx, req.(*CancelLikeAcademicNavigatorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AcademicNavigatorService_ServiceDesc is the grpc.ServiceDesc for AcademicNavigatorService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AcademicNavigatorService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "coderhub.AcademicNavigatorService",
	HandlerType: (*AcademicNavigatorServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddAcademicNavigator",
			Handler:    _AcademicNavigatorService_AddAcademicNavigator_Handler,
		},
		{
			MethodName: "GetAcademicNavigator",
			Handler:    _AcademicNavigatorService_GetAcademicNavigator_Handler,
		},
		{
			MethodName: "DeleteAcademicNavigator",
			Handler:    _AcademicNavigatorService_DeleteAcademicNavigator_Handler,
		},
		{
			MethodName: "LikeAcademicNavigator",
			Handler:    _AcademicNavigatorService_LikeAcademicNavigator_Handler,
		},
		{
			MethodName: "CancelLikeAcademicNavigator",
			Handler:    _AcademicNavigatorService_CancelLikeAcademicNavigator_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "coderhub.proto",
}

const (
	ArticleService_GetArticle_FullMethodName      = "/coderhub.ArticleService/GetArticle"
	ArticleService_CreateArticle_FullMethodName   = "/coderhub.ArticleService/CreateArticle"
	ArticleService_UpdateArticle_FullMethodName   = "/coderhub.ArticleService/UpdateArticle"
	ArticleService_UpdateLikeCount_FullMethodName = "/coderhub.ArticleService/UpdateLikeCount"
	ArticleService_DeleteArticle_FullMethodName   = "/coderhub.ArticleService/DeleteArticle"
)

// ArticleServiceClient is the client API for ArticleService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// RPC 服务定义
type ArticleServiceClient interface {
	GetArticle(ctx context.Context, in *GetArticleRequest, opts ...grpc.CallOption) (*GetArticleResponse, error)
	CreateArticle(ctx context.Context, in *CreateArticleRequest, opts ...grpc.CallOption) (*CreateArticleResponse, error)
	UpdateArticle(ctx context.Context, in *UpdateArticleRequest, opts ...grpc.CallOption) (*UpdateArticleResponse, error)
	UpdateLikeCount(ctx context.Context, in *UpdateLikeCountRequest, opts ...grpc.CallOption) (*UpdateLikeCountResponse, error)
	DeleteArticle(ctx context.Context, in *DeleteArticleRequest, opts ...grpc.CallOption) (*DeleteArticleResponse, error)
}

type articleServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewArticleServiceClient(cc grpc.ClientConnInterface) ArticleServiceClient {
	return &articleServiceClient{cc}
}

func (c *articleServiceClient) GetArticle(ctx context.Context, in *GetArticleRequest, opts ...grpc.CallOption) (*GetArticleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetArticleResponse)
	err := c.cc.Invoke(ctx, ArticleService_GetArticle_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *articleServiceClient) CreateArticle(ctx context.Context, in *CreateArticleRequest, opts ...grpc.CallOption) (*CreateArticleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateArticleResponse)
	err := c.cc.Invoke(ctx, ArticleService_CreateArticle_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *articleServiceClient) UpdateArticle(ctx context.Context, in *UpdateArticleRequest, opts ...grpc.CallOption) (*UpdateArticleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateArticleResponse)
	err := c.cc.Invoke(ctx, ArticleService_UpdateArticle_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *articleServiceClient) UpdateLikeCount(ctx context.Context, in *UpdateLikeCountRequest, opts ...grpc.CallOption) (*UpdateLikeCountResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateLikeCountResponse)
	err := c.cc.Invoke(ctx, ArticleService_UpdateLikeCount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *articleServiceClient) DeleteArticle(ctx context.Context, in *DeleteArticleRequest, opts ...grpc.CallOption) (*DeleteArticleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteArticleResponse)
	err := c.cc.Invoke(ctx, ArticleService_DeleteArticle_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ArticleServiceServer is the server API for ArticleService service.
// All implementations must embed UnimplementedArticleServiceServer
// for forward compatibility.
//
// RPC 服务定义
type ArticleServiceServer interface {
	GetArticle(context.Context, *GetArticleRequest) (*GetArticleResponse, error)
	CreateArticle(context.Context, *CreateArticleRequest) (*CreateArticleResponse, error)
	UpdateArticle(context.Context, *UpdateArticleRequest) (*UpdateArticleResponse, error)
	UpdateLikeCount(context.Context, *UpdateLikeCountRequest) (*UpdateLikeCountResponse, error)
	DeleteArticle(context.Context, *DeleteArticleRequest) (*DeleteArticleResponse, error)
	mustEmbedUnimplementedArticleServiceServer()
}

// UnimplementedArticleServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedArticleServiceServer struct{}

func (UnimplementedArticleServiceServer) GetArticle(context.Context, *GetArticleRequest) (*GetArticleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetArticle not implemented")
}
func (UnimplementedArticleServiceServer) CreateArticle(context.Context, *CreateArticleRequest) (*CreateArticleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateArticle not implemented")
}
func (UnimplementedArticleServiceServer) UpdateArticle(context.Context, *UpdateArticleRequest) (*UpdateArticleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateArticle not implemented")
}
func (UnimplementedArticleServiceServer) UpdateLikeCount(context.Context, *UpdateLikeCountRequest) (*UpdateLikeCountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateLikeCount not implemented")
}
func (UnimplementedArticleServiceServer) DeleteArticle(context.Context, *DeleteArticleRequest) (*DeleteArticleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteArticle not implemented")
}
func (UnimplementedArticleServiceServer) mustEmbedUnimplementedArticleServiceServer() {}
func (UnimplementedArticleServiceServer) testEmbeddedByValue()                        {}

// UnsafeArticleServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ArticleServiceServer will
// result in compilation errors.
type UnsafeArticleServiceServer interface {
	mustEmbedUnimplementedArticleServiceServer()
}

func RegisterArticleServiceServer(s grpc.ServiceRegistrar, srv ArticleServiceServer) {
	// If the following call pancis, it indicates UnimplementedArticleServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ArticleService_ServiceDesc, srv)
}

func _ArticleService_GetArticle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetArticleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArticleServiceServer).GetArticle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ArticleService_GetArticle_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArticleServiceServer).GetArticle(ctx, req.(*GetArticleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArticleService_CreateArticle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateArticleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArticleServiceServer).CreateArticle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ArticleService_CreateArticle_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArticleServiceServer).CreateArticle(ctx, req.(*CreateArticleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArticleService_UpdateArticle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateArticleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArticleServiceServer).UpdateArticle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ArticleService_UpdateArticle_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArticleServiceServer).UpdateArticle(ctx, req.(*UpdateArticleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArticleService_UpdateLikeCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateLikeCountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArticleServiceServer).UpdateLikeCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ArticleService_UpdateLikeCount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArticleServiceServer).UpdateLikeCount(ctx, req.(*UpdateLikeCountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArticleService_DeleteArticle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteArticleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArticleServiceServer).DeleteArticle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ArticleService_DeleteArticle_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArticleServiceServer).DeleteArticle(ctx, req.(*DeleteArticleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ArticleService_ServiceDesc is the grpc.ServiceDesc for ArticleService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ArticleService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "coderhub.ArticleService",
	HandlerType: (*ArticleServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetArticle",
			Handler:    _ArticleService_GetArticle_Handler,
		},
		{
			MethodName: "CreateArticle",
			Handler:    _ArticleService_CreateArticle_Handler,
		},
		{
			MethodName: "UpdateArticle",
			Handler:    _ArticleService_UpdateArticle_Handler,
		},
		{
			MethodName: "UpdateLikeCount",
			Handler:    _ArticleService_UpdateLikeCount_Handler,
		},
		{
			MethodName: "DeleteArticle",
			Handler:    _ArticleService_DeleteArticle_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "coderhub.proto",
}

const (
	CommentService_CreateComment_FullMethodName          = "/coderhub.CommentService/CreateComment"
	CommentService_GetComments_FullMethodName            = "/coderhub.CommentService/GetComments"
	CommentService_GetCommentReplies_FullMethodName      = "/coderhub.CommentService/GetCommentReplies"
	CommentService_UpdateCommentLikeCount_FullMethodName = "/coderhub.CommentService/UpdateCommentLikeCount"
	CommentService_GetComment_FullMethodName             = "/coderhub.CommentService/GetComment"
	CommentService_DeleteComment_FullMethodName          = "/coderhub.CommentService/DeleteComment"
)

// CommentServiceClient is the client API for CommentService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// 评论服务定义
type CommentServiceClient interface {
	// 创建评论
	CreateComment(ctx context.Context, in *CreateCommentRequest, opts ...grpc.CallOption) (*CreateCommentResponse, error)
	// 获取评论列表
	GetComments(ctx context.Context, in *GetCommentsRequest, opts ...grpc.CallOption) (*GetCommentsResponse, error)
	// 获取某条评论的子评论列表
	GetCommentReplies(ctx context.Context, in *GetCommentRepliesRequest, opts ...grpc.CallOption) (*GetCommentRepliesResponse, error)
	// 更新评论点赞数
	UpdateCommentLikeCount(ctx context.Context, in *UpdateCommentLikeCountRequest, opts ...grpc.CallOption) (*UpdateCommentLikeCountResponse, error)
	// 获取单个评论详情
	GetComment(ctx context.Context, in *GetCommentRequest, opts ...grpc.CallOption) (*GetCommentResponse, error)
	// 删除评论
	DeleteComment(ctx context.Context, in *DeleteCommentRequest, opts ...grpc.CallOption) (*DeleteCommentResponse, error)
}

type commentServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCommentServiceClient(cc grpc.ClientConnInterface) CommentServiceClient {
	return &commentServiceClient{cc}
}

func (c *commentServiceClient) CreateComment(ctx context.Context, in *CreateCommentRequest, opts ...grpc.CallOption) (*CreateCommentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateCommentResponse)
	err := c.cc.Invoke(ctx, CommentService_CreateComment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commentServiceClient) GetComments(ctx context.Context, in *GetCommentsRequest, opts ...grpc.CallOption) (*GetCommentsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetCommentsResponse)
	err := c.cc.Invoke(ctx, CommentService_GetComments_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commentServiceClient) GetCommentReplies(ctx context.Context, in *GetCommentRepliesRequest, opts ...grpc.CallOption) (*GetCommentRepliesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetCommentRepliesResponse)
	err := c.cc.Invoke(ctx, CommentService_GetCommentReplies_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commentServiceClient) UpdateCommentLikeCount(ctx context.Context, in *UpdateCommentLikeCountRequest, opts ...grpc.CallOption) (*UpdateCommentLikeCountResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateCommentLikeCountResponse)
	err := c.cc.Invoke(ctx, CommentService_UpdateCommentLikeCount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commentServiceClient) GetComment(ctx context.Context, in *GetCommentRequest, opts ...grpc.CallOption) (*GetCommentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetCommentResponse)
	err := c.cc.Invoke(ctx, CommentService_GetComment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commentServiceClient) DeleteComment(ctx context.Context, in *DeleteCommentRequest, opts ...grpc.CallOption) (*DeleteCommentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteCommentResponse)
	err := c.cc.Invoke(ctx, CommentService_DeleteComment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CommentServiceServer is the server API for CommentService service.
// All implementations must embed UnimplementedCommentServiceServer
// for forward compatibility.
//
// 评论服务定义
type CommentServiceServer interface {
	// 创建评论
	CreateComment(context.Context, *CreateCommentRequest) (*CreateCommentResponse, error)
	// 获取评论列表
	GetComments(context.Context, *GetCommentsRequest) (*GetCommentsResponse, error)
	// 获取某条评论的子评论列表
	GetCommentReplies(context.Context, *GetCommentRepliesRequest) (*GetCommentRepliesResponse, error)
	// 更新评论点赞数
	UpdateCommentLikeCount(context.Context, *UpdateCommentLikeCountRequest) (*UpdateCommentLikeCountResponse, error)
	// 获取单个评论详情
	GetComment(context.Context, *GetCommentRequest) (*GetCommentResponse, error)
	// 删除评论
	DeleteComment(context.Context, *DeleteCommentRequest) (*DeleteCommentResponse, error)
	mustEmbedUnimplementedCommentServiceServer()
}

// UnimplementedCommentServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCommentServiceServer struct{}

func (UnimplementedCommentServiceServer) CreateComment(context.Context, *CreateCommentRequest) (*CreateCommentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateComment not implemented")
}
func (UnimplementedCommentServiceServer) GetComments(context.Context, *GetCommentsRequest) (*GetCommentsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetComments not implemented")
}
func (UnimplementedCommentServiceServer) GetCommentReplies(context.Context, *GetCommentRepliesRequest) (*GetCommentRepliesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCommentReplies not implemented")
}
func (UnimplementedCommentServiceServer) UpdateCommentLikeCount(context.Context, *UpdateCommentLikeCountRequest) (*UpdateCommentLikeCountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCommentLikeCount not implemented")
}
func (UnimplementedCommentServiceServer) GetComment(context.Context, *GetCommentRequest) (*GetCommentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetComment not implemented")
}
func (UnimplementedCommentServiceServer) DeleteComment(context.Context, *DeleteCommentRequest) (*DeleteCommentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteComment not implemented")
}
func (UnimplementedCommentServiceServer) mustEmbedUnimplementedCommentServiceServer() {}
func (UnimplementedCommentServiceServer) testEmbeddedByValue()                        {}

// UnsafeCommentServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CommentServiceServer will
// result in compilation errors.
type UnsafeCommentServiceServer interface {
	mustEmbedUnimplementedCommentServiceServer()
}

func RegisterCommentServiceServer(s grpc.ServiceRegistrar, srv CommentServiceServer) {
	// If the following call pancis, it indicates UnimplementedCommentServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CommentService_ServiceDesc, srv)
}

func _CommentService_CreateComment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateCommentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommentServiceServer).CreateComment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommentService_CreateComment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommentServiceServer).CreateComment(ctx, req.(*CreateCommentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommentService_GetComments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCommentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommentServiceServer).GetComments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommentService_GetComments_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommentServiceServer).GetComments(ctx, req.(*GetCommentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommentService_GetCommentReplies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCommentRepliesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommentServiceServer).GetCommentReplies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommentService_GetCommentReplies_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommentServiceServer).GetCommentReplies(ctx, req.(*GetCommentRepliesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommentService_UpdateCommentLikeCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateCommentLikeCountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommentServiceServer).UpdateCommentLikeCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommentService_UpdateCommentLikeCount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommentServiceServer).UpdateCommentLikeCount(ctx, req.(*UpdateCommentLikeCountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommentService_GetComment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCommentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommentServiceServer).GetComment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommentService_GetComment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommentServiceServer).GetComment(ctx, req.(*GetCommentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommentService_DeleteComment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteCommentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommentServiceServer).DeleteComment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommentService_DeleteComment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommentServiceServer).DeleteComment(ctx, req.(*DeleteCommentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CommentService_ServiceDesc is the grpc.ServiceDesc for CommentService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CommentService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "coderhub.CommentService",
	HandlerType: (*CommentServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateComment",
			Handler:    _CommentService_CreateComment_Handler,
		},
		{
			MethodName: "GetComments",
			Handler:    _CommentService_GetComments_Handler,
		},
		{
			MethodName: "GetCommentReplies",
			Handler:    _CommentService_GetCommentReplies_Handler,
		},
		{
			MethodName: "UpdateCommentLikeCount",
			Handler:    _CommentService_UpdateCommentLikeCount_Handler,
		},
		{
			MethodName: "GetComment",
			Handler:    _CommentService_GetComment_Handler,
		},
		{
			MethodName: "DeleteComment",
			Handler:    _CommentService_DeleteComment_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "coderhub.proto",
}

const (
	ImageRelationService_CreateRelation_FullMethodName         = "/coderhub.ImageRelationService/CreateRelation"
	ImageRelationService_BatchCreateRelation_FullMethodName    = "/coderhub.ImageRelationService/BatchCreateRelation"
	ImageRelationService_BatchDeleteRelation_FullMethodName    = "/coderhub.ImageRelationService/BatchDeleteRelation"
	ImageRelationService_BatchGetImagesByEntity_FullMethodName = "/coderhub.ImageRelationService/BatchGetImagesByEntity"
	ImageRelationService_DeleteByEntityID_FullMethodName       = "/coderhub.ImageRelationService/DeleteByEntityID"
	ImageRelationService_GetImagesByEntity_FullMethodName      = "/coderhub.ImageRelationService/GetImagesByEntity"
	ImageRelationService_GetEntitiesByImage_FullMethodName     = "/coderhub.ImageRelationService/GetEntitiesByImage"
)

// ImageRelationServiceClient is the client API for ImageRelationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// 图片关系服务
type ImageRelationServiceClient interface {
	// 创建图片关系
	CreateRelation(ctx context.Context, in *CreateRelationRequest, opts ...grpc.CallOption) (*CreateRelationResponse, error)
	// 批量创建图片关系
	BatchCreateRelation(ctx context.Context, in *BatchCreateRelationRequest, opts ...grpc.CallOption) (*BatchCreateRelationResponse, error)
	// 批量删除图片关系
	BatchDeleteRelation(ctx context.Context, in *BatchDeleteRelationRequest, opts ...grpc.CallOption) (*BatchDeleteRelationResponse, error)
	// 批量获取图片关联，根据实体ID列表、实体类型列表获取
	BatchGetImagesByEntity(ctx context.Context, in *BatchGetImagesByEntityRequest, opts ...grpc.CallOption) (*BatchGetImagesByEntityResponse, error)
	// 根据实体ID、实体类型删除图片关系
	DeleteByEntityID(ctx context.Context, in *DeleteByEntityIDRequest, opts ...grpc.CallOption) (*DeleteByEntityIDResponse, error)
	// 获取实体关联的图片列表
	GetImagesByEntity(ctx context.Context, in *GetImagesByEntityRequest, opts ...grpc.CallOption) (*GetImagesByEntityResponse, error)
	// 获取图片关联的实体列表
	GetEntitiesByImage(ctx context.Context, in *GetEntitiesByImageRequest, opts ...grpc.CallOption) (*GetEntitiesByImageResponse, error)
}

type imageRelationServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewImageRelationServiceClient(cc grpc.ClientConnInterface) ImageRelationServiceClient {
	return &imageRelationServiceClient{cc}
}

func (c *imageRelationServiceClient) CreateRelation(ctx context.Context, in *CreateRelationRequest, opts ...grpc.CallOption) (*CreateRelationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateRelationResponse)
	err := c.cc.Invoke(ctx, ImageRelationService_CreateRelation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imageRelationServiceClient) BatchCreateRelation(ctx context.Context, in *BatchCreateRelationRequest, opts ...grpc.CallOption) (*BatchCreateRelationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BatchCreateRelationResponse)
	err := c.cc.Invoke(ctx, ImageRelationService_BatchCreateRelation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imageRelationServiceClient) BatchDeleteRelation(ctx context.Context, in *BatchDeleteRelationRequest, opts ...grpc.CallOption) (*BatchDeleteRelationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BatchDeleteRelationResponse)
	err := c.cc.Invoke(ctx, ImageRelationService_BatchDeleteRelation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imageRelationServiceClient) BatchGetImagesByEntity(ctx context.Context, in *BatchGetImagesByEntityRequest, opts ...grpc.CallOption) (*BatchGetImagesByEntityResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BatchGetImagesByEntityResponse)
	err := c.cc.Invoke(ctx, ImageRelationService_BatchGetImagesByEntity_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imageRelationServiceClient) DeleteByEntityID(ctx context.Context, in *DeleteByEntityIDRequest, opts ...grpc.CallOption) (*DeleteByEntityIDResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteByEntityIDResponse)
	err := c.cc.Invoke(ctx, ImageRelationService_DeleteByEntityID_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imageRelationServiceClient) GetImagesByEntity(ctx context.Context, in *GetImagesByEntityRequest, opts ...grpc.CallOption) (*GetImagesByEntityResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetImagesByEntityResponse)
	err := c.cc.Invoke(ctx, ImageRelationService_GetImagesByEntity_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imageRelationServiceClient) GetEntitiesByImage(ctx context.Context, in *GetEntitiesByImageRequest, opts ...grpc.CallOption) (*GetEntitiesByImageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetEntitiesByImageResponse)
	err := c.cc.Invoke(ctx, ImageRelationService_GetEntitiesByImage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ImageRelationServiceServer is the server API for ImageRelationService service.
// All implementations must embed UnimplementedImageRelationServiceServer
// for forward compatibility.
//
// 图片关系服务
type ImageRelationServiceServer interface {
	// 创建图片关系
	CreateRelation(context.Context, *CreateRelationRequest) (*CreateRelationResponse, error)
	// 批量创建图片关系
	BatchCreateRelation(context.Context, *BatchCreateRelationRequest) (*BatchCreateRelationResponse, error)
	// 批量删除图片关系
	BatchDeleteRelation(context.Context, *BatchDeleteRelationRequest) (*BatchDeleteRelationResponse, error)
	// 批量获取图片关联，根据实体ID列表、实体类型列表获取
	BatchGetImagesByEntity(context.Context, *BatchGetImagesByEntityRequest) (*BatchGetImagesByEntityResponse, error)
	// 根据实体ID、实体类型删除图片关系
	DeleteByEntityID(context.Context, *DeleteByEntityIDRequest) (*DeleteByEntityIDResponse, error)
	// 获取实体关联的图片列表
	GetImagesByEntity(context.Context, *GetImagesByEntityRequest) (*GetImagesByEntityResponse, error)
	// 获取图片关联的实体列表
	GetEntitiesByImage(context.Context, *GetEntitiesByImageRequest) (*GetEntitiesByImageResponse, error)
	mustEmbedUnimplementedImageRelationServiceServer()
}

// UnimplementedImageRelationServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedImageRelationServiceServer struct{}

func (UnimplementedImageRelationServiceServer) CreateRelation(context.Context, *CreateRelationRequest) (*CreateRelationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateRelation not implemented")
}
func (UnimplementedImageRelationServiceServer) BatchCreateRelation(context.Context, *BatchCreateRelationRequest) (*BatchCreateRelationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchCreateRelation not implemented")
}
func (UnimplementedImageRelationServiceServer) BatchDeleteRelation(context.Context, *BatchDeleteRelationRequest) (*BatchDeleteRelationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchDeleteRelation not implemented")
}
func (UnimplementedImageRelationServiceServer) BatchGetImagesByEntity(context.Context, *BatchGetImagesByEntityRequest) (*BatchGetImagesByEntityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchGetImagesByEntity not implemented")
}
func (UnimplementedImageRelationServiceServer) DeleteByEntityID(context.Context, *DeleteByEntityIDRequest) (*DeleteByEntityIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteByEntityID not implemented")
}
func (UnimplementedImageRelationServiceServer) GetImagesByEntity(context.Context, *GetImagesByEntityRequest) (*GetImagesByEntityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetImagesByEntity not implemented")
}
func (UnimplementedImageRelationServiceServer) GetEntitiesByImage(context.Context, *GetEntitiesByImageRequest) (*GetEntitiesByImageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetEntitiesByImage not implemented")
}
func (UnimplementedImageRelationServiceServer) mustEmbedUnimplementedImageRelationServiceServer() {}
func (UnimplementedImageRelationServiceServer) testEmbeddedByValue()                              {}

// UnsafeImageRelationServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ImageRelationServiceServer will
// result in compilation errors.
type UnsafeImageRelationServiceServer interface {
	mustEmbedUnimplementedImageRelationServiceServer()
}

func RegisterImageRelationServiceServer(s grpc.ServiceRegistrar, srv ImageRelationServiceServer) {
	// If the following call pancis, it indicates UnimplementedImageRelationServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ImageRelationService_ServiceDesc, srv)
}

func _ImageRelationService_CreateRelation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateRelationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImageRelationServiceServer).CreateRelation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ImageRelationService_CreateRelation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImageRelationServiceServer).CreateRelation(ctx, req.(*CreateRelationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImageRelationService_BatchCreateRelation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchCreateRelationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImageRelationServiceServer).BatchCreateRelation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ImageRelationService_BatchCreateRelation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImageRelationServiceServer).BatchCreateRelation(ctx, req.(*BatchCreateRelationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImageRelationService_BatchDeleteRelation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchDeleteRelationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImageRelationServiceServer).BatchDeleteRelation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ImageRelationService_BatchDeleteRelation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImageRelationServiceServer).BatchDeleteRelation(ctx, req.(*BatchDeleteRelationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImageRelationService_BatchGetImagesByEntity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchGetImagesByEntityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImageRelationServiceServer).BatchGetImagesByEntity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ImageRelationService_BatchGetImagesByEntity_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImageRelationServiceServer).BatchGetImagesByEntity(ctx, req.(*BatchGetImagesByEntityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImageRelationService_DeleteByEntityID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteByEntityIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImageRelationServiceServer).DeleteByEntityID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ImageRelationService_DeleteByEntityID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImageRelationServiceServer).DeleteByEntityID(ctx, req.(*DeleteByEntityIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImageRelationService_GetImagesByEntity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetImagesByEntityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImageRelationServiceServer).GetImagesByEntity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ImageRelationService_GetImagesByEntity_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImageRelationServiceServer).GetImagesByEntity(ctx, req.(*GetImagesByEntityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImageRelationService_GetEntitiesByImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetEntitiesByImageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImageRelationServiceServer).GetEntitiesByImage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ImageRelationService_GetEntitiesByImage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImageRelationServiceServer).GetEntitiesByImage(ctx, req.(*GetEntitiesByImageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ImageRelationService_ServiceDesc is the grpc.ServiceDesc for ImageRelationService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ImageRelationService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "coderhub.ImageRelationService",
	HandlerType: (*ImageRelationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateRelation",
			Handler:    _ImageRelationService_CreateRelation_Handler,
		},
		{
			MethodName: "BatchCreateRelation",
			Handler:    _ImageRelationService_BatchCreateRelation_Handler,
		},
		{
			MethodName: "BatchDeleteRelation",
			Handler:    _ImageRelationService_BatchDeleteRelation_Handler,
		},
		{
			MethodName: "BatchGetImagesByEntity",
			Handler:    _ImageRelationService_BatchGetImagesByEntity_Handler,
		},
		{
			MethodName: "DeleteByEntityID",
			Handler:    _ImageRelationService_DeleteByEntityID_Handler,
		},
		{
			MethodName: "GetImagesByEntity",
			Handler:    _ImageRelationService_GetImagesByEntity_Handler,
		},
		{
			MethodName: "GetEntitiesByImage",
			Handler:    _ImageRelationService_GetEntitiesByImage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "coderhub.proto",
}

const (
	ImageService_Upload_FullMethodName     = "/coderhub.ImageService/Upload"
	ImageService_Delete_FullMethodName     = "/coderhub.ImageService/Delete"
	ImageService_Get_FullMethodName        = "/coderhub.ImageService/Get"
	ImageService_BatchGet_FullMethodName   = "/coderhub.ImageService/BatchGet"
	ImageService_ListByUser_FullMethodName = "/coderhub.ImageService/ListByUser"
)

// ImageServiceClient is the client API for ImageService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// 图片服务
type ImageServiceClient interface {
	// 上传图片
	Upload(ctx context.Context, in *UploadRequest, opts ...grpc.CallOption) (*ImageInfo, error)
	// 删除图片
	Delete(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*DeleteResponse, error)
	// 获取图片信息
	Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*ImageInfo, error)
	// 批量获取图片信息
	BatchGet(ctx context.Context, in *BatchGetRequest, opts ...grpc.CallOption) (*BatchGetResponse, error)
	// 获取用户图片列表
	ListByUser(ctx context.Context, in *ListByUserRequest, opts ...grpc.CallOption) (*ListByUserResponse, error)
}

type imageServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewImageServiceClient(cc grpc.ClientConnInterface) ImageServiceClient {
	return &imageServiceClient{cc}
}

func (c *imageServiceClient) Upload(ctx context.Context, in *UploadRequest, opts ...grpc.CallOption) (*ImageInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ImageInfo)
	err := c.cc.Invoke(ctx, ImageService_Upload_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imageServiceClient) Delete(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*DeleteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteResponse)
	err := c.cc.Invoke(ctx, ImageService_Delete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imageServiceClient) Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*ImageInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ImageInfo)
	err := c.cc.Invoke(ctx, ImageService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imageServiceClient) BatchGet(ctx context.Context, in *BatchGetRequest, opts ...grpc.CallOption) (*BatchGetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BatchGetResponse)
	err := c.cc.Invoke(ctx, ImageService_BatchGet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imageServiceClient) ListByUser(ctx context.Context, in *ListByUserRequest, opts ...grpc.CallOption) (*ListByUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListByUserResponse)
	err := c.cc.Invoke(ctx, ImageService_ListByUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ImageServiceServer is the server API for ImageService service.
// All implementations must embed UnimplementedImageServiceServer
// for forward compatibility.
//
// 图片服务
type ImageServiceServer interface {
	// 上传图片
	Upload(context.Context, *UploadRequest) (*ImageInfo, error)
	// 删除图片
	Delete(context.Context, *DeleteRequest) (*DeleteResponse, error)
	// 获取图片信息
	Get(context.Context, *GetRequest) (*ImageInfo, error)
	// 批量获取图片信息
	BatchGet(context.Context, *BatchGetRequest) (*BatchGetResponse, error)
	// 获取用户图片列表
	ListByUser(context.Context, *ListByUserRequest) (*ListByUserResponse, error)
	mustEmbedUnimplementedImageServiceServer()
}

// UnimplementedImageServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedImageServiceServer struct{}

func (UnimplementedImageServiceServer) Upload(context.Context, *UploadRequest) (*ImageInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Upload not implemented")
}
func (UnimplementedImageServiceServer) Delete(context.Context, *DeleteRequest) (*DeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedImageServiceServer) Get(context.Context, *GetRequest) (*ImageInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedImageServiceServer) BatchGet(context.Context, *BatchGetRequest) (*BatchGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchGet not implemented")
}
func (UnimplementedImageServiceServer) ListByUser(context.Context, *ListByUserRequest) (*ListByUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListByUser not implemented")
}
func (UnimplementedImageServiceServer) mustEmbedUnimplementedImageServiceServer() {}
func (UnimplementedImageServiceServer) testEmbeddedByValue()                      {}

// UnsafeImageServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ImageServiceServer will
// result in compilation errors.
type UnsafeImageServiceServer interface {
	mustEmbedUnimplementedImageServiceServer()
}

func RegisterImageServiceServer(s grpc.ServiceRegistrar, srv ImageServiceServer) {
	// If the following call pancis, it indicates UnimplementedImageServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ImageService_ServiceDesc, srv)
}

func _ImageService_Upload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UploadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImageServiceServer).Upload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ImageService_Upload_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImageServiceServer).Upload(ctx, req.(*UploadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImageService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImageServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ImageService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImageServiceServer).Delete(ctx, req.(*DeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImageService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImageServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ImageService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImageServiceServer).Get(ctx, req.(*GetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImageService_BatchGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImageServiceServer).BatchGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ImageService_BatchGet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImageServiceServer).BatchGet(ctx, req.(*BatchGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImageService_ListByUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListByUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImageServiceServer).ListByUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ImageService_ListByUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImageServiceServer).ListByUser(ctx, req.(*ListByUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ImageService_ServiceDesc is the grpc.ServiceDesc for ImageService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ImageService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "coderhub.ImageService",
	HandlerType: (*ImageServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Upload",
			Handler:    _ImageService_Upload_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _ImageService_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _ImageService_Get_Handler,
		},
		{
			MethodName: "BatchGet",
			Handler:    _ImageService_BatchGet_Handler,
		},
		{
			MethodName: "ListByUser",
			Handler:    _ImageService_ListByUser_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "coderhub.proto",
}

const (
	QuestionService_CreateQuestionBank_FullMethodName  = "/coderhub.QuestionService/CreateQuestionBank"
	QuestionService_DeleteQuestionBank_FullMethodName  = "/coderhub.QuestionService/DeleteQuestionBank"
	QuestionService_CreateQuestion_FullMethodName      = "/coderhub.QuestionService/CreateQuestion"
	QuestionService_DeleteQuestion_FullMethodName      = "/coderhub.QuestionService/DeleteQuestion"
	QuestionService_GetQuestionBankList_FullMethodName = "/coderhub.QuestionService/GetQuestionBankList"
	QuestionService_GetQuestionTree_FullMethodName     = "/coderhub.QuestionService/GetQuestionTree"
	QuestionService_GetQuestion_FullMethodName         = "/coderhub.QuestionService/GetQuestion"
)

// QuestionServiceClient is the client API for QuestionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type QuestionServiceClient interface {
	// 创建题库
	CreateQuestionBank(ctx context.Context, in *CreateQuestionBankRequest, opts ...grpc.CallOption) (*CreateQuestionBankResponse, error)
	// 删除题库
	DeleteQuestionBank(ctx context.Context, in *DeleteQuestionBankRequest, opts ...grpc.CallOption) (*DeleteQuestionBankResponse, error)
	// 创建题目
	CreateQuestion(ctx context.Context, in *CreateQuestionRequest, opts ...grpc.CallOption) (*CreateQuestionResponse, error)
	// 删除题目
	DeleteQuestion(ctx context.Context, in *DeleteQuestionRequest, opts ...grpc.CallOption) (*DeleteQuestionResponse, error)
	// 获取题库列表
	GetQuestionBankList(ctx context.Context, in *GetQuestionBankListRequest, opts ...grpc.CallOption) (*GetQuestionBankListResponse, error)
	// 获取题库下的所有题目目录
	GetQuestionTree(ctx context.Context, in *GetQuestionTreeRequest, opts ...grpc.CallOption) (*GetQuestionTreeResponse, error)
	// 获取题目详情
	GetQuestion(ctx context.Context, in *GetQuestionRequest, opts ...grpc.CallOption) (*GetQuestionResponse, error)
}

type questionServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewQuestionServiceClient(cc grpc.ClientConnInterface) QuestionServiceClient {
	return &questionServiceClient{cc}
}

func (c *questionServiceClient) CreateQuestionBank(ctx context.Context, in *CreateQuestionBankRequest, opts ...grpc.CallOption) (*CreateQuestionBankResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateQuestionBankResponse)
	err := c.cc.Invoke(ctx, QuestionService_CreateQuestionBank_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *questionServiceClient) DeleteQuestionBank(ctx context.Context, in *DeleteQuestionBankRequest, opts ...grpc.CallOption) (*DeleteQuestionBankResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteQuestionBankResponse)
	err := c.cc.Invoke(ctx, QuestionService_DeleteQuestionBank_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *questionServiceClient) CreateQuestion(ctx context.Context, in *CreateQuestionRequest, opts ...grpc.CallOption) (*CreateQuestionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateQuestionResponse)
	err := c.cc.Invoke(ctx, QuestionService_CreateQuestion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *questionServiceClient) DeleteQuestion(ctx context.Context, in *DeleteQuestionRequest, opts ...grpc.CallOption) (*DeleteQuestionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteQuestionResponse)
	err := c.cc.Invoke(ctx, QuestionService_DeleteQuestion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *questionServiceClient) GetQuestionBankList(ctx context.Context, in *GetQuestionBankListRequest, opts ...grpc.CallOption) (*GetQuestionBankListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetQuestionBankListResponse)
	err := c.cc.Invoke(ctx, QuestionService_GetQuestionBankList_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *questionServiceClient) GetQuestionTree(ctx context.Context, in *GetQuestionTreeRequest, opts ...grpc.CallOption) (*GetQuestionTreeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetQuestionTreeResponse)
	err := c.cc.Invoke(ctx, QuestionService_GetQuestionTree_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *questionServiceClient) GetQuestion(ctx context.Context, in *GetQuestionRequest, opts ...grpc.CallOption) (*GetQuestionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetQuestionResponse)
	err := c.cc.Invoke(ctx, QuestionService_GetQuestion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QuestionServiceServer is the server API for QuestionService service.
// All implementations must embed UnimplementedQuestionServiceServer
// for forward compatibility.
type QuestionServiceServer interface {
	// 创建题库
	CreateQuestionBank(context.Context, *CreateQuestionBankRequest) (*CreateQuestionBankResponse, error)
	// 删除题库
	DeleteQuestionBank(context.Context, *DeleteQuestionBankRequest) (*DeleteQuestionBankResponse, error)
	// 创建题目
	CreateQuestion(context.Context, *CreateQuestionRequest) (*CreateQuestionResponse, error)
	// 删除题目
	DeleteQuestion(context.Context, *DeleteQuestionRequest) (*DeleteQuestionResponse, error)
	// 获取题库列表
	GetQuestionBankList(context.Context, *GetQuestionBankListRequest) (*GetQuestionBankListResponse, error)
	// 获取题库下的所有题目目录
	GetQuestionTree(context.Context, *GetQuestionTreeRequest) (*GetQuestionTreeResponse, error)
	// 获取题目详情
	GetQuestion(context.Context, *GetQuestionRequest) (*GetQuestionResponse, error)
	mustEmbedUnimplementedQuestionServiceServer()
}

// UnimplementedQuestionServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedQuestionServiceServer struct{}

func (UnimplementedQuestionServiceServer) CreateQuestionBank(context.Context, *CreateQuestionBankRequest) (*CreateQuestionBankResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateQuestionBank not implemented")
}
func (UnimplementedQuestionServiceServer) DeleteQuestionBank(context.Context, *DeleteQuestionBankRequest) (*DeleteQuestionBankResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteQuestionBank not implemented")
}
func (UnimplementedQuestionServiceServer) CreateQuestion(context.Context, *CreateQuestionRequest) (*CreateQuestionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateQuestion not implemented")
}
func (UnimplementedQuestionServiceServer) DeleteQuestion(context.Context, *DeleteQuestionRequest) (*DeleteQuestionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteQuestion not implemented")
}
func (UnimplementedQuestionServiceServer) GetQuestionBankList(context.Context, *GetQuestionBankListRequest) (*GetQuestionBankListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetQuestionBankList not implemented")
}
func (UnimplementedQuestionServiceServer) GetQuestionTree(context.Context, *GetQuestionTreeRequest) (*GetQuestionTreeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetQuestionTree not implemented")
}
func (UnimplementedQuestionServiceServer) GetQuestion(context.Context, *GetQuestionRequest) (*GetQuestionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetQuestion not implemented")
}
func (UnimplementedQuestionServiceServer) mustEmbedUnimplementedQuestionServiceServer() {}
func (UnimplementedQuestionServiceServer) testEmbeddedByValue()                         {}

// UnsafeQuestionServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to QuestionServiceServer will
// result in compilation errors.
type UnsafeQuestionServiceServer interface {
	mustEmbedUnimplementedQuestionServiceServer()
}

func RegisterQuestionServiceServer(s grpc.ServiceRegistrar, srv QuestionServiceServer) {
	// If the following call pancis, it indicates UnimplementedQuestionServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&QuestionService_ServiceDesc, srv)
}

func _QuestionService_CreateQuestionBank_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateQuestionBankRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuestionServiceServer).CreateQuestionBank(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QuestionService_CreateQuestionBank_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuestionServiceServer).CreateQuestionBank(ctx, req.(*CreateQuestionBankRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QuestionService_DeleteQuestionBank_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteQuestionBankRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuestionServiceServer).DeleteQuestionBank(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QuestionService_DeleteQuestionBank_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuestionServiceServer).DeleteQuestionBank(ctx, req.(*DeleteQuestionBankRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QuestionService_CreateQuestion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateQuestionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuestionServiceServer).CreateQuestion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QuestionService_CreateQuestion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuestionServiceServer).CreateQuestion(ctx, req.(*CreateQuestionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QuestionService_DeleteQuestion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteQuestionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuestionServiceServer).DeleteQuestion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QuestionService_DeleteQuestion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuestionServiceServer).DeleteQuestion(ctx, req.(*DeleteQuestionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QuestionService_GetQuestionBankList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetQuestionBankListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuestionServiceServer).GetQuestionBankList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QuestionService_GetQuestionBankList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuestionServiceServer).GetQuestionBankList(ctx, req.(*GetQuestionBankListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QuestionService_GetQuestionTree_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetQuestionTreeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuestionServiceServer).GetQuestionTree(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QuestionService_GetQuestionTree_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuestionServiceServer).GetQuestionTree(ctx, req.(*GetQuestionTreeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QuestionService_GetQuestion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetQuestionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuestionServiceServer).GetQuestion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QuestionService_GetQuestion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuestionServiceServer).GetQuestion(ctx, req.(*GetQuestionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// QuestionService_ServiceDesc is the grpc.ServiceDesc for QuestionService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var QuestionService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "coderhub.QuestionService",
	HandlerType: (*QuestionServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateQuestionBank",
			Handler:    _QuestionService_CreateQuestionBank_Handler,
		},
		{
			MethodName: "DeleteQuestionBank",
			Handler:    _QuestionService_DeleteQuestionBank_Handler,
		},
		{
			MethodName: "CreateQuestion",
			Handler:    _QuestionService_CreateQuestion_Handler,
		},
		{
			MethodName: "DeleteQuestion",
			Handler:    _QuestionService_DeleteQuestion_Handler,
		},
		{
			MethodName: "GetQuestionBankList",
			Handler:    _QuestionService_GetQuestionBankList_Handler,
		},
		{
			MethodName: "GetQuestionTree",
			Handler:    _QuestionService_GetQuestionTree_Handler,
		},
		{
			MethodName: "GetQuestion",
			Handler:    _QuestionService_GetQuestion_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "coderhub.proto",
}
